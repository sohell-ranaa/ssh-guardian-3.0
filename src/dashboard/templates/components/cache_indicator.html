<!-- SSH Guardian v3.0 - Cache Status Indicator Component -->
<!-- Shows cache status for each page with refresh controls -->

<style>
/* Cache Indicator Styles */
.cache-indicator {
    display: inline-flex;
    align-items: center;
    gap: 8px;
    padding: 6px 12px;
    border-radius: 6px;
    font-size: 12px;
    font-weight: 500;
    background: var(--bg-secondary);
    border: 1px solid var(--border-color);
    transition: all 0.3s ease;
}

.cache-indicator.cached {
    background: rgba(16, 185, 129, 0.1);
    border-color: rgba(16, 185, 129, 0.3);
    color: #10b981;
}

.cache-indicator.fresh {
    background: rgba(59, 130, 246, 0.1);
    border-color: rgba(59, 130, 246, 0.3);
    color: #3b82f6;
}

.cache-indicator.loading {
    background: rgba(245, 158, 11, 0.1);
    border-color: rgba(245, 158, 11, 0.3);
    color: #f59e0b;
}

.cache-indicator.error {
    background: rgba(239, 68, 68, 0.1);
    border-color: rgba(239, 68, 68, 0.3);
    color: #ef4444;
}

.cache-indicator.stale {
    background: rgba(156, 163, 175, 0.1);
    border-color: rgba(156, 163, 175, 0.3);
    color: #9ca3af;
}

.cache-status-dot {
    width: 8px;
    height: 8px;
    border-radius: 50%;
    background: currentColor;
    animation: none;
}

.cache-indicator.loading .cache-status-dot {
    animation: pulse-dot 1s ease-in-out infinite;
}

@keyframes pulse-dot {
    0%, 100% { opacity: 1; transform: scale(1); }
    50% { opacity: 0.5; transform: scale(0.8); }
}

.cache-indicator-text {
    white-space: nowrap;
}

.cache-time {
    font-size: 10px;
    opacity: 0.8;
    margin-left: 4px;
}

.cache-refresh-btn {
    background: none;
    border: none;
    color: inherit;
    cursor: pointer;
    padding: 2px 6px;
    border-radius: 4px;
    font-size: 14px;
    transition: background 0.2s;
    display: flex;
    align-items: center;
    justify-content: center;
}

.cache-refresh-btn:hover {
    background: rgba(255, 255, 255, 0.1);
}

.cache-refresh-btn:disabled {
    opacity: 0.5;
    cursor: not-allowed;
}

.cache-refresh-btn.spinning {
    animation: spin 1s linear infinite;
}

@keyframes spin {
    from { transform: rotate(0deg); }
    to { transform: rotate(360deg); }
}

/* Page Header with Cache Info */
.page-header-with-cache {
    display: flex;
    justify-content: space-between;
    align-items: center;
    flex-wrap: wrap;
    gap: 12px;
    margin-bottom: 20px;
}

.page-header-with-cache h2 {
    margin: 0;
    display: flex;
    align-items: center;
    gap: 10px;
}

.page-header-actions {
    display: flex;
    align-items: center;
    gap: 10px;
}

/* Global Cache Panel Overlay */
.cache-panel-overlay {
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    z-index: 999;
    display: none;
}

.cache-panel-overlay.visible {
    display: block;
}

/* Global Cache Status Bar */
.global-cache-bar {
    position: fixed;
    top: 60px;
    right: 20px;
    z-index: 1000;
    background: var(--card-bg, var(--surface));
    border: 1px solid var(--border);
    border-radius: 8px;
    padding: 12px 16px;
    box-shadow: 0 8px 24px rgba(0, 0, 0, 0.4);
    display: none;
    flex-direction: column;
    gap: 8px;
    min-width: 300px;
    max-height: 400px;
    overflow-y: auto;
}

.global-cache-bar.visible {
    display: flex;
}

.global-cache-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding-bottom: 8px;
    border-bottom: 1px solid var(--border);
}

.global-cache-header h4 {
    margin: 0;
    font-size: 14px;
    color: var(--text-primary, inherit);
}

.global-cache-close {
    background: none;
    border: none;
    color: var(--text-secondary);
    cursor: pointer;
    font-size: 18px;
    padding: 4px 8px;
    line-height: 1;
    border-radius: 4px;
    transition: background 0.2s, color 0.2s;
}

.global-cache-close:hover {
    background: var(--background);
    color: var(--text-primary, inherit);
}

.cache-item-row {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 8px 0;
    font-size: 12px;
    border-bottom: 1px solid var(--border-light, var(--border));
}

.cache-item-row:last-child {
    border-bottom: none;
}

.cache-item-name {
    color: var(--text-primary, inherit);
    font-weight: 500;
}

.cache-item-status {
    display: flex;
    align-items: center;
    gap: 6px;
}

.cache-item-ttl {
    color: var(--text-secondary);
    font-size: 10px;
}

.cache-actions-row {
    display: flex;
    gap: 8px;
    padding-top: 12px;
    margin-top: 4px;
    border-top: 1px solid var(--border);
}

.cache-action-btn {
    flex: 1;
    padding: 6px 12px;
    border: none;
    border-radius: 4px;
    font-size: 11px;
    font-weight: 500;
    cursor: pointer;
    transition: all 0.2s;
}

.cache-action-btn.clear-browser-cache {
    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
    color: white;
}

.cache-action-btn.clear-browser-cache:hover {
    background: linear-gradient(135deg, #5568d3 0%, #653a8b 100%);
    transform: translateY(-1px);
    box-shadow: 0 4px 12px rgba(102, 126, 234, 0.4);
}

.cache-action-btn.clear-all {
    background: #ef4444;
    color: white;
}

.cache-action-btn.clear-all:hover {
    background: #dc2626;
}

/* Cache Toggle Button in Header */
.cache-toggle-btn {
    position: relative;
    background: var(--bg-secondary);
    border: 1px solid var(--border-color);
    border-radius: 6px;
    padding: 6px 10px;
    color: var(--text-primary);
    cursor: pointer;
    display: flex;
    align-items: center;
    gap: 6px;
    font-size: 12px;
    transition: all 0.2s;
}

.cache-toggle-btn:hover {
    background: var(--bg-hover);
}

.cache-toggle-btn .cache-count,
.cache-count {
    background: #3b82f6;
    color: white;
    padding: 2px 6px;
    border-radius: 10px;
    font-size: 10px;
    font-weight: 600;
    min-width: 16px;
    text-align: center;
    display: inline-block;
}

/* Toast Notifications */
.cache-toast {
    position: fixed;
    bottom: 20px;
    right: 20px;
    padding: 16px 24px;
    border-radius: 12px;
    font-size: 13px;
    font-weight: 500;
    box-shadow: 0 8px 24px rgba(0, 0, 0, 0.4);
    transform: translateY(100px);
    opacity: 0;
    transition: all 0.3s ease;
    z-index: 9999;
    max-width: 400px;
    white-space: pre-line;
    line-height: 1.6;
}

.cache-toast.show {
    transform: translateY(0);
    opacity: 1;
}

.cache-toast.success {
    background: linear-gradient(135deg, #10b981 0%, #059669 100%);
    color: white;
}

.cache-toast.info {
    background: linear-gradient(135deg, #3b82f6 0%, #2563eb 100%);
    color: white;
}

.cache-toast.warning {
    background: linear-gradient(135deg, #f59e0b 0%, #d97706 100%);
    color: white;
}

.cache-toast.error {
    background: linear-gradient(135deg, #ef4444 0%, #dc2626 100%);
    color: white;
}
</style>

<!-- Cache Toast Container -->
<div id="cacheToast" class="cache-toast"></div>

<!-- Cache Panel Overlay (for click-outside-to-close) -->
<div id="cachePanelOverlay" class="cache-panel-overlay" onclick="CacheManager.closePanel()"></div>

<!-- Global Cache Panel -->
<div id="globalCacheBar" class="global-cache-bar">
    <div class="global-cache-header">
        <h4>Cache Status</h4>
        <button class="global-cache-close" onclick="CacheManager.togglePanel()">&times;</button>
    </div>
    <div id="cacheItemsList">
        <!-- Dynamic cache items will be inserted here -->
    </div>
    <div class="cache-actions-row">
        <button class="cache-action-btn clear-browser-cache" onclick="CacheManager.clearBrowserCache()">
            ðŸ§¹ Clear Browser Cache
        </button>
        <button class="cache-action-btn clear-all" onclick="CacheManager.clearAll()">
            Clear Server Cache
        </button>
    </div>
</div>

<script>
// Global Cache Manager
const CacheManager = {
    // Track cache status for each endpoint
    cacheStatus: {},

    // TTL values (in seconds) - LOADED FROM API
    // Default fallbacks until API loads
    ttlMap: {
        'events': 120,
        'threat_intel': 7200,
        'geoip': 7200,
        'trends': 1800,
        'reports': 1800,
        'ip_stats': 600
    },

    // Whether TTL map has been loaded from API
    ttlMapLoaded: false,

    // Cacheable endpoints (loaded from API)
    cacheableEndpoints: [],

    // Initialize cache manager
    async init() {
        // Load TTL map from API
        await this.loadTtlMap();

        // Add cache toggle button to header if not exists
        this.addCacheToggleButton();

        // Start periodic status check
        setInterval(() => this.updateAllCacheTimers(), 1000);

        // Reload TTL map periodically (every 60 seconds) to pick up settings changes
        setInterval(() => this.loadTtlMap(), 60000);
    },

    // Load TTL map from API (database-driven)
    async loadTtlMap() {
        try {
            const response = await fetch('/api/dashboard/cache-settings/ttl-map', {
                headers: { 'Cache-Control': 'no-cache' }
            });
            const data = await response.json();

            if (data.success && data.ttl_map) {
                this.ttlMap = { ...this.ttlMap, ...data.ttl_map };
                this.ttlMapLoaded = true;
                if (data.cacheable_endpoints) {
                    this.cacheableEndpoints = data.cacheable_endpoints;
                }
                console.log('[CacheManager] TTL map loaded from database');
            }
        } catch (error) {
            console.warn('[CacheManager] Failed to load TTL map from API, using defaults');
        }
    },

    // Add cache toggle button to header
    addCacheToggleButton() {
        const header = document.querySelector('.header-actions');
        if (header && !document.getElementById('cacheToggleBtn')) {
            const btn = document.createElement('button');
            btn.id = 'cacheToggleBtn';
            btn.className = 'cache-toggle-btn';
            btn.innerHTML = `
                <span>Cache</span>
                <span class="cache-count" id="activeCacheCount">0</span>
            `;
            btn.onclick = () => this.togglePanel();
            header.insertBefore(btn, header.firstChild);
        }
    },

    // Toggle cache panel visibility
    togglePanel() {
        const panel = document.getElementById('globalCacheBar');
        const overlay = document.getElementById('cachePanelOverlay');
        const isVisible = panel.classList.contains('visible');

        if (isVisible) {
            this.closePanel();
        } else {
            panel.classList.add('visible');
            overlay.classList.add('visible');
            this.refreshPanelList();
        }
    },

    // Close cache panel
    closePanel() {
        const panel = document.getElementById('globalCacheBar');
        const overlay = document.getElementById('cachePanelOverlay');
        panel.classList.remove('visible');
        overlay.classList.remove('visible');
    },

    // Update cache status for a specific endpoint
    updateStatus(endpoint, fromCache, loadTime = null) {
        const now = Date.now();
        this.cacheStatus[endpoint] = {
            fromCache: fromCache,
            lastUpdate: now,
            loadTime: loadTime,
            ttl: this.ttlMap[endpoint] || 60
        };

        this.updateCacheCount();
        this.updatePageIndicator(endpoint);
    },

    // Update the cache count badge
    updateCacheCount() {
        const count = Object.keys(this.cacheStatus).length;
        const badge = document.getElementById('activeCacheCount');
        if (badge) {
            badge.textContent = count;
        }
    },

    // Update all cache timers (called every second)
    updateAllCacheTimers() {
        const now = Date.now();
        for (const [endpoint, status] of Object.entries(this.cacheStatus)) {
            const elapsed = Math.floor((now - status.lastUpdate) / 1000);
            const remaining = Math.max(0, status.ttl - elapsed);

            // Update indicator if exists
            const indicator = document.querySelector(`[data-cache-endpoint="${endpoint}"] .cache-time`);
            if (indicator) {
                if (status.fromCache) {
                    indicator.textContent = remaining > 0 ? `${remaining}s` : 'Stale';
                } else {
                    indicator.textContent = `${elapsed}s ago`;
                }
            }

            // Mark as stale if TTL expired
            if (remaining === 0 && status.fromCache) {
                const indicatorEl = document.querySelector(`[data-cache-endpoint="${endpoint}"]`);
                if (indicatorEl) {
                    indicatorEl.classList.remove('cached');
                    indicatorEl.classList.add('stale');
                }
            }
        }
    },

    // Update the page-level cache indicator
    updatePageIndicator(endpoint) {
        const status = this.cacheStatus[endpoint];
        const indicator = document.querySelector(`[data-cache-endpoint="${endpoint}"]`);

        if (indicator) {
            indicator.classList.remove('cached', 'fresh', 'loading', 'error', 'stale');

            if (status.fromCache) {
                indicator.classList.add('cached');
                indicator.querySelector('.cache-indicator-text').textContent = 'Cached';
            } else {
                indicator.classList.add('fresh');
                indicator.querySelector('.cache-indicator-text').textContent = 'Fresh';
            }

            if (status.loadTime) {
                const timeEl = indicator.querySelector('.cache-time');
                if (timeEl) {
                    timeEl.textContent = status.fromCache ? `${status.ttl}s` : `${status.loadTime}ms`;
                }
            }
        }
    },

    // Set loading state for endpoint
    setLoading(endpoint) {
        const indicator = document.querySelector(`[data-cache-endpoint="${endpoint}"]`);
        if (indicator) {
            indicator.classList.remove('cached', 'fresh', 'error', 'stale');
            indicator.classList.add('loading');
            indicator.querySelector('.cache-indicator-text').textContent = 'Loading...';

            const refreshBtn = indicator.querySelector('.cache-refresh-btn');
            if (refreshBtn) {
                refreshBtn.classList.add('spinning');
                refreshBtn.disabled = true;
            }
        }
    },

    // Set error state for endpoint
    setError(endpoint, message) {
        const indicator = document.querySelector(`[data-cache-endpoint="${endpoint}"]`);
        if (indicator) {
            indicator.classList.remove('cached', 'fresh', 'loading', 'stale');
            indicator.classList.add('error');
            indicator.querySelector('.cache-indicator-text').textContent = 'Error';

            const refreshBtn = indicator.querySelector('.cache-refresh-btn');
            if (refreshBtn) {
                refreshBtn.classList.remove('spinning');
                refreshBtn.disabled = false;
            }
        }

        this.showToast(message || 'Failed to load data', 'error');
    },

    // Clear loading state
    clearLoading(endpoint) {
        const indicator = document.querySelector(`[data-cache-endpoint="${endpoint}"]`);
        if (indicator) {
            const refreshBtn = indicator.querySelector('.cache-refresh-btn');
            if (refreshBtn) {
                refreshBtn.classList.remove('spinning');
                refreshBtn.disabled = false;
            }
        }
    },

    // Refresh panel list with current cache items
    refreshPanelList() {
        const list = document.getElementById('cacheItemsList');
        if (!list) return;

        const now = Date.now();
        let html = '';

        for (const [endpoint, status] of Object.entries(this.cacheStatus)) {
            const elapsed = Math.floor((now - status.lastUpdate) / 1000);
            const remaining = Math.max(0, status.ttl - elapsed);
            const statusClass = status.fromCache ? (remaining > 0 ? 'cached' : 'stale') : 'fresh';
            const statusText = status.fromCache ? (remaining > 0 ? 'Cached' : 'Stale') : 'Fresh';

            html += `
                <div class="cache-item-row">
                    <span class="cache-item-name">${this.formatEndpointName(endpoint)}</span>
                    <span class="cache-item-status">
                        <span class="cache-indicator ${statusClass}" style="padding: 2px 8px;">
                            <span class="cache-status-dot"></span>
                            <span>${statusText}</span>
                        </span>
                        <span class="cache-item-ttl">${remaining > 0 ? remaining + 's' : '-'}</span>
                    </span>
                </div>
            `;
        }

        if (html === '') {
            html = '<div style="text-align: center; color: var(--text-secondary); padding: 20px;">No cached data yet</div>';
        }

        list.innerHTML = html;
    },

    // Format endpoint name for display
    formatEndpointName(endpoint) {
        return endpoint
            .replace(/_/g, ' ')
            .replace(/\b\w/g, l => l.toUpperCase());
    },

    // Refresh specific endpoint
    async refresh(endpoint, refreshFn) {
        this.setLoading(endpoint);

        try {
            const startTime = performance.now();
            await refreshFn();
            const loadTime = Math.round(performance.now() - startTime);

            this.showToast(`${this.formatEndpointName(endpoint)} refreshed (${loadTime}ms)`, 'success');
        } catch (error) {
            this.setError(endpoint, `Failed to refresh ${this.formatEndpointName(endpoint)}`);
        }
    },

    // Clear browser cache (NEW - Universal solution)
    async clearBrowserCache() {
        this.showToast('Clearing browser & server cache...', 'info');

        try {
            const response = await fetch('/api/dashboard/cache-settings/clear-browser-cache', {
                method: 'POST',
                headers: {
                    'Cache-Control': 'no-cache'
                }
            });
            const result = await response.json();

            if (result.success) {
                // Clear local tracking
                this.cacheStatus = {};
                this.updateCacheCount();
                this.refreshPanelList();

                // Show success message with details
                const details = result.details || {};
                const message = `âœ… All caches cleared!\n` +
                    `   â€¢ Redis keys: ${details.redis_keys_deleted || 0}\n` +
                    `   â€¢ Browser cache: Cleared\n` +
                    `   â€¢ Fresh data will load now`;

                this.showToast(message, 'success');

                // Trigger page reload to fetch completely fresh data
                setTimeout(() => {
                    const hash = window.location.hash.substring(1) || 'dashboard';
                    if (typeof showPage === 'function') {
                        showPage(hash);
                    } else {
                        window.location.reload(true); // Force reload
                    }
                }, 1000);

            } else {
                this.showToast(result.error || 'Failed to clear browser cache', 'error');
            }
        } catch (error) {
            this.showToast('Failed to clear browser cache: ' + error.message, 'error');
        }
    },

    // Clear server cache only
    async clearAll() {
        if (!confirm('Clear server cache only? (Use "Clear Browser Cache" for complete clearing)')) {
            return;
        }

        try {
            const response = await fetch('/api/dashboard/cache-settings/clear', {
                method: 'POST',
                headers: {
                    'Cache-Control': 'no-cache'
                }
            });
            const result = await response.json();

            if (result.success) {
                this.cacheStatus = {};
                this.updateCacheCount();
                this.refreshPanelList();
                this.showToast(`Server cache cleared (${result.message || 'success'})`, 'success');

                // Reload current page
                setTimeout(() => {
                    const hash = window.location.hash.substring(1) || 'dashboard';
                    if (typeof showPage === 'function') {
                        showPage(hash);
                    }
                }, 500);
            } else {
                this.showToast(result.error || 'Failed to clear cache', 'error');
            }
        } catch (error) {
            this.showToast('Failed to clear server cache', 'error');
        }
    },

    // Show toast notification
    showToast(message, type = 'info', duration = null) {
        const toast = document.getElementById('cacheToast');
        if (!toast) return;

        toast.textContent = message;
        toast.className = `cache-toast ${type} show`;

        // Auto-dismiss duration (longer for success messages with details)
        const dismissTime = duration || (type === 'success' && message.includes('\n') ? 5000 : 3000);

        setTimeout(() => {
            toast.classList.remove('show');
        }, dismissTime);
    },

    // Create page header with cache indicator
    createPageHeader(title, icon, endpoint, refreshFn) {
        return `
            <div class="page-header-with-cache">
                <h2>${icon} ${title}</h2>
                <div class="page-header-actions">
                    <div class="cache-indicator loading" data-cache-endpoint="${endpoint}">
                        <span class="cache-status-dot"></span>
                        <span class="cache-indicator-text">Loading...</span>
                        <span class="cache-time"></span>
                        <button class="cache-refresh-btn" onclick="CacheManager.refresh('${endpoint}', ${refreshFn.name || 'loadPageData'})" title="Refresh data">
                            â†»
                        </button>
                    </div>
                </div>
            </div>
        `;
    }
};

// Initialize on page load
document.addEventListener('DOMContentLoaded', () => {
    CacheManager.init();
});

// Helper function to wrap fetch calls with cache tracking
async function fetchWithCache(url, endpoint, options = {}) {
    const startTime = performance.now();
    CacheManager.setLoading(endpoint);

    try {
        const response = await fetch(url, options);
        const data = await response.json();
        const loadTime = Math.round(performance.now() - startTime);

        // Check if data came from cache
        const fromCache = data.from_cache === true;

        CacheManager.updateStatus(endpoint, fromCache, loadTime);
        CacheManager.clearLoading(endpoint);

        return data;
    } catch (error) {
        CacheManager.setError(endpoint, `Failed to fetch ${endpoint}`);
        throw error;
    }
}
</script>
