<!-- SSH Guardian v3.0 - ML Training & Data Management Page -->
<div id="page-ml-training" class="page-content" style="display: none;">
    <div class="page-header-with-cache">
        <div>
            <h2 style="margin: 0 0 8px 0; color: var(--text-primary); font-size: 24px; font-weight: 600;">
                ML Training & Data Management
            </h2>
            <p style="margin: 0; color: var(--text-secondary); font-size: 14px;">
                Generate training data, train models, and manage the ML pipeline
            </p>
        </div>
        <div class="page-header-actions">
            <div class="cache-indicator loading" data-cache-endpoint="ml_training">
                <span class="cache-status-dot"></span>
                <span class="cache-indicator-text">Loading...</span>
                <span class="cache-time"></span>
                <button class="cache-refresh-btn" onclick="refreshTrainingPage()" title="Refresh data">â†»</button>
            </div>
        </div>
    </div>

    <!-- Data Statistics Overview -->
    <div class="training-stats-grid">
        <div class="card stat-card">
            <div class="stat-label">Total Events</div>
            <div class="stat-value stat-blue" id="stats-total-events">-</div>
        </div>
        <div class="card stat-card">
            <div class="stat-label">Failed Events</div>
            <div class="stat-value stat-red" id="stats-failed-events">-</div>
        </div>
        <div class="card stat-card">
            <div class="stat-label">Success Events</div>
            <div class="stat-value stat-green" id="stats-success-events">-</div>
        </div>
        <div class="card stat-card">
            <div class="stat-label">Unique IPs</div>
            <div class="stat-value" id="stats-unique-ips">-</div>
        </div>
        <div class="card stat-card">
            <div class="stat-label">Trained Models</div>
            <div class="stat-value stat-green" id="stats-trained-models">-</div>
        </div>
        <div class="card stat-card">
            <div class="stat-label">Active Model</div>
            <div class="stat-value stat-blue stat-small" id="stats-active-model">-</div>
        </div>
    </div>

    <!-- Main Grid: Simulation & Training Side by Side -->
    <div class="training-main-grid">
        <!-- Generate Training Data Section -->
        <div class="card" style="padding: 20px;">
            <h3 class="section-title">
                <span class="section-icon">ðŸ“Š</span> Generate Training Data
            </h3>

            <div class="form-group">
                <label class="form-label">Attack Template</label>
                <select id="sim-template" class="form-select">
                    <option value="">Loading templates...</option>
                </select>
            </div>

            <div id="sim-template-info" class="template-info" style="display: none;">
                <div class="template-info-label">Description</div>
                <div id="sim-template-desc" class="template-info-desc"></div>
            </div>

            <div class="form-row">
                <div class="form-group">
                    <label class="form-label">Event Count</label>
                    <input type="number" id="sim-event-count" value="50" min="10" max="500" class="form-input">
                </div>
                <div class="form-group">
                    <label class="form-label">Delay (ms)</label>
                    <input type="number" id="sim-delay" value="50" min="0" max="1000" class="form-input">
                </div>
            </div>

            <button onclick="runSimulation()" id="run-sim-btn" class="btn btn-warning btn-full">
                Generate Events
            </button>

            <div id="sim-progress" class="progress-container" style="display: none;">
                <div class="progress-header">
                    <span id="sim-status" class="progress-status">Running...</span>
                    <span id="sim-progress-text" class="progress-percent">0%</span>
                </div>
                <div class="progress-track">
                    <div id="sim-progress-bar" class="progress-bar progress-bar-warning"></div>
                </div>
            </div>

            <!-- Quick Generate Buttons -->
            <div class="quick-generate-section">
                <div class="quick-generate-label">Quick Generate (50 events each):</div>
                <div class="quick-generate-buttons">
                    <button onclick="quickGenerate('brute_force', this)" class="quick-gen-btn">Brute Force</button>
                    <button onclick="quickGenerate('distributed_brute_force', this)" class="quick-gen-btn">Distributed</button>
                    <button onclick="quickGenerate('credential_stuffing', this)" class="quick-gen-btn">Credential Stuffing</button>
                    <button onclick="quickGenerate('reconnaissance', this)" class="quick-gen-btn">Recon</button>
                    <button onclick="quickGenerate('slow_brute_force', this)" class="quick-gen-btn">Slow Attack</button>
                </div>
            </div>
        </div>

        <!-- Train Model Section -->
        <div class="card" style="padding: 20px;">
            <h3 class="section-title">
                <span class="section-icon">ðŸ¤–</span> Train New Model
            </h3>

            <div class="form-group">
                <label class="form-label">Algorithm</label>
                <select id="training-algorithm" class="form-select">
                    <option value="random_forest">Random Forest (Recommended)</option>
                    <option value="gradient_boosting">Gradient Boosting</option>
                    <option value="xgboost">XGBoost</option>
                    <option value="all">All Algorithms (Auto-select best)</option>
                </select>
            </div>

            <div class="form-row">
                <div class="form-group">
                    <label class="form-label">Start Date</label>
                    <input type="date" id="training-start-date" class="form-input">
                </div>
                <div class="form-group">
                    <label class="form-label">End Date</label>
                    <input type="date" id="training-end-date" class="form-input">
                </div>
            </div>

            <div class="form-group">
                <label class="checkbox-label">
                    <input type="checkbox" id="training-include-sim" checked class="checkbox-input">
                    <span>Include simulation data</span>
                </label>
            </div>

            <!-- Train/Test Split Info -->
            <div class="info-box info-box-blue">
                <span class="info-icon">ðŸ“ˆ</span>
                <div>
                    <div class="info-title">Train/Test Split: 80% / 20%</div>
                    <div class="info-desc">Standard ML practice for balanced training</div>
                </div>
            </div>

            <button onclick="startTraining()" id="start-training-btn" class="btn btn-success btn-full">
                Start Training
            </button>

            <div id="training-progress" class="progress-container" style="display: none;">
                <div class="progress-header">
                    <span id="training-stage" class="progress-status">Initializing...</span>
                    <span id="training-progress-percent" class="progress-percent">0%</span>
                </div>
                <div class="progress-track">
                    <div id="training-progress-bar" class="progress-bar progress-bar-success"></div>
                </div>
                <div id="training-message" class="progress-message"></div>
            </div>

            <!-- Minimum Data Warning -->
            <div id="min-data-warning" class="warning-box" style="display: none;">
                <div class="warning-title">Not enough training data</div>
                <div class="warning-desc">Minimum 100 events required. Generate more data using the simulation panel.</div>
            </div>
        </div>
    </div>

    <!-- Model Management Section -->
    <div class="card" style="padding: 20px; margin-bottom: 24px;">
        <h3 class="section-title">
            <span class="section-icon">ðŸ“¦</span> Trained Models
        </h3>
        <div id="models-container">
            <div class="loading-placeholder">Loading models...</div>
        </div>
    </div>

    <!-- Training History -->
    <div class="card" style="padding: 20px;">
        <h3 class="section-title">Training History</h3>
        <div class="table-wrapper">
            <table class="data-table">
                <thead>
                    <tr>
                        <th>Run ID</th>
                        <th>Algorithm</th>
                        <th class="text-center">Samples (Train/Test)</th>
                        <th class="text-center">Status</th>
                        <th class="text-center">Duration</th>
                        <th class="text-center">F1 Score</th>
                        <th>Started</th>
                    </tr>
                </thead>
                <tbody id="training-history-body">
                    <tr>
                        <td colspan="7" class="loading-placeholder">Loading...</td>
                    </tr>
                </tbody>
            </table>
        </div>
    </div>
</div>

<style>
/* ML Training Page Styles */
#page-ml-training .training-stats-grid {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(130px, 1fr));
    gap: 12px;
    margin-bottom: 24px;
}

#page-ml-training .stat-card {
    padding: 16px;
    text-align: center;
}

#page-ml-training .stat-label {
    color: var(--text-secondary);
    font-size: 11px;
    text-transform: uppercase;
    letter-spacing: 0.5px;
    margin-bottom: 6px;
}

#page-ml-training .stat-value {
    font-size: 24px;
    font-weight: 600;
    color: var(--text-primary);
}

#page-ml-training .stat-value.stat-blue { color: var(--azure-blue); }
#page-ml-training .stat-value.stat-red { color: #D13438; }
#page-ml-training .stat-value.stat-green { color: #2EA44F; }
#page-ml-training .stat-value.stat-small { font-size: 14px; }

#page-ml-training .training-main-grid {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 24px;
    margin-bottom: 24px;
}

@media (max-width: 900px) {
    #page-ml-training .training-main-grid {
        grid-template-columns: 1fr;
    }
}

#page-ml-training .section-title {
    margin: 0 0 16px 0;
    font-size: 16px;
    font-weight: 600;
    color: var(--text-primary);
    display: flex;
    align-items: center;
    gap: 8px;
}

#page-ml-training .section-icon {
    font-size: 20px;
}

/* Form Styles */
#page-ml-training .form-group {
    margin-bottom: 16px;
}

#page-ml-training .form-label {
    display: block;
    font-size: 12px;
    color: var(--text-secondary);
    margin-bottom: 4px;
}

#page-ml-training .form-input,
#page-ml-training .form-select {
    width: 100%;
    padding: 10px;
    border: 1px solid var(--border);
    border-radius: 4px;
    background: var(--surface);
    color: var(--text-primary);
    font-size: 13px;
    transition: border-color 0.2s;
}

#page-ml-training .form-input:focus,
#page-ml-training .form-select:focus {
    outline: none;
    border-color: var(--azure-blue);
}

#page-ml-training .form-row {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 12px;
}

#page-ml-training .checkbox-label {
    display: flex;
    align-items: center;
    gap: 8px;
    cursor: pointer;
    font-size: 13px;
    color: var(--text-primary);
}

#page-ml-training .checkbox-input {
    width: 16px;
    height: 16px;
    cursor: pointer;
}

/* Template Info */
#page-ml-training .template-info {
    background: var(--background);
    border-radius: 4px;
    padding: 12px;
    margin-bottom: 16px;
}

#page-ml-training .template-info-label {
    font-size: 11px;
    color: var(--text-secondary);
    margin-bottom: 4px;
}

#page-ml-training .template-info-desc {
    font-size: 13px;
    color: var(--text-primary);
}

/* Buttons */
#page-ml-training .btn {
    padding: 12px;
    border: none;
    border-radius: 4px;
    cursor: pointer;
    font-size: 14px;
    font-weight: 600;
    transition: all 0.2s;
}

#page-ml-training .btn-full {
    width: 100%;
}

#page-ml-training .btn-success {
    background: #2EA44F;
    color: white;
}

#page-ml-training .btn-success:hover:not(:disabled) {
    background: #268f42;
}

#page-ml-training .btn-warning {
    background: #E6A502;
    color: white;
}

#page-ml-training .btn-warning:hover:not(:disabled) {
    background: #cc9302;
}

#page-ml-training .btn:disabled {
    opacity: 0.6;
    cursor: not-allowed;
}

/* Progress */
#page-ml-training .progress-container {
    margin-top: 16px;
}

#page-ml-training .progress-header {
    display: flex;
    justify-content: space-between;
    margin-bottom: 4px;
}

#page-ml-training .progress-status {
    font-size: 12px;
    color: var(--text-primary);
}

#page-ml-training .progress-percent {
    font-size: 12px;
    color: var(--azure-blue);
    font-weight: 600;
}

#page-ml-training .progress-track {
    height: 6px;
    background: var(--background);
    border-radius: 3px;
    overflow: hidden;
}

#page-ml-training .progress-bar {
    height: 100%;
    width: 0%;
    transition: width 0.3s;
    border-radius: 3px;
}

#page-ml-training .progress-bar-warning {
    background: #E6A502;
}

#page-ml-training .progress-bar-success {
    background: #2EA44F;
}

#page-ml-training .progress-bar-error {
    background: #D13438;
}

#page-ml-training .progress-message {
    font-size: 11px;
    color: var(--text-secondary);
    margin-top: 8px;
}

/* Quick Generate */
#page-ml-training .quick-generate-section {
    margin-top: 16px;
    padding-top: 16px;
    border-top: 1px solid var(--border);
}

#page-ml-training .quick-generate-label {
    font-size: 12px;
    color: var(--text-secondary);
    margin-bottom: 8px;
}

#page-ml-training .quick-generate-buttons {
    display: flex;
    flex-wrap: wrap;
    gap: 6px;
}

#page-ml-training .quick-gen-btn {
    padding: 6px 10px;
    font-size: 11px;
    background: var(--surface);
    border: 1px solid var(--border);
    border-radius: 4px;
    cursor: pointer;
    color: var(--text-primary);
    transition: all 0.2s;
}

#page-ml-training .quick-gen-btn:hover:not(:disabled) {
    border-color: var(--azure-blue);
    background: rgba(0, 120, 212, 0.05);
}

#page-ml-training .quick-gen-btn:disabled {
    opacity: 0.6;
    cursor: not-allowed;
}

#page-ml-training .quick-gen-btn.loading {
    background: var(--azure-blue);
    color: white;
    border-color: var(--azure-blue);
}

/* Info & Warning Boxes */
#page-ml-training .info-box {
    display: flex;
    align-items: center;
    gap: 8px;
    padding: 12px;
    border-radius: 4px;
    margin-bottom: 16px;
}

#page-ml-training .info-box-blue {
    background: rgba(0, 120, 212, 0.1);
}

#page-ml-training .info-icon {
    font-size: 18px;
}

#page-ml-training .info-title {
    font-weight: 600;
    color: var(--text-primary);
    font-size: 13px;
}

#page-ml-training .info-desc {
    font-size: 11px;
    color: var(--text-secondary);
}

#page-ml-training .warning-box {
    margin-top: 16px;
    padding: 12px;
    background: rgba(230, 165, 2, 0.1);
    border-radius: 4px;
    border-left: 3px solid #E6A502;
}

#page-ml-training .warning-title {
    font-size: 12px;
    color: #E6A502;
    font-weight: 600;
}

#page-ml-training .warning-desc {
    font-size: 11px;
    color: var(--text-secondary);
    margin-top: 4px;
}

/* Loading Placeholder */
#page-ml-training .loading-placeholder {
    color: var(--text-secondary);
    padding: 20px;
    text-align: center;
}

/* Data Table */
#page-ml-training .data-table {
    width: 100%;
    border-collapse: collapse;
    font-size: 13px;
}

#page-ml-training .data-table thead tr {
    background: var(--background);
    border-bottom: 2px solid var(--border);
}

#page-ml-training .data-table th {
    padding: 12px;
    text-align: left;
    font-weight: 600;
    color: var(--text-primary);
}

#page-ml-training .data-table th.text-center {
    text-align: center;
}

#page-ml-training .data-table td {
    padding: 12px;
    border-bottom: 1px solid var(--border);
    color: var(--text-primary);
}

#page-ml-training .data-table td.text-center {
    text-align: center;
}

/* Model Cards */
#page-ml-training .models-grid {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
    gap: 16px;
}

#page-ml-training .model-card {
    padding: 16px;
    border: 1px solid var(--border);
    border-radius: 8px;
    background: var(--background);
    transition: all 0.2s;
}

#page-ml-training .model-card.active {
    background: rgba(46, 164, 79, 0.05);
    border-color: #2EA44F;
}

#page-ml-training .model-header {
    display: flex;
    justify-content: space-between;
    align-items: start;
    margin-bottom: 12px;
}

#page-ml-training .model-name {
    font-weight: 600;
    color: var(--text-primary);
    font-size: 14px;
}

#page-ml-training .model-version {
    font-size: 11px;
    color: var(--text-secondary);
}

#page-ml-training .model-badge {
    padding: 4px 8px;
    border-radius: 4px;
    font-size: 10px;
    font-weight: 600;
}

#page-ml-training .model-badge.active {
    background: rgba(46, 164, 79, 0.2);
    color: #2EA44F;
}

#page-ml-training .model-badge.candidate {
    background: rgba(0, 120, 212, 0.2);
    color: var(--azure-blue);
}

#page-ml-training .model-badge.deprecated {
    background: rgba(128, 128, 128, 0.2);
    color: var(--text-secondary);
}

#page-ml-training .model-metrics {
    display: grid;
    grid-template-columns: repeat(2, 1fr);
    gap: 8px;
    margin-bottom: 12px;
}

#page-ml-training .metric-label {
    font-size: 10px;
    color: var(--text-secondary);
}

#page-ml-training .metric-value {
    font-size: 14px;
    font-weight: 600;
}

#page-ml-training .metric-value.good {
    color: #2EA44F;
}

#page-ml-training .model-samples {
    font-size: 11px;
    color: var(--text-secondary);
    margin-bottom: 12px;
}

#page-ml-training .model-actions {
    display: flex;
    gap: 8px;
}

#page-ml-training .model-actions .btn {
    flex: 1;
    padding: 8px;
    font-size: 12px;
}

#page-ml-training .btn-outline-danger {
    background: var(--surface);
    color: #D13438;
    border: 1px solid #D13438;
}

#page-ml-training .btn-outline-danger:hover {
    background: rgba(209, 52, 56, 0.1);
}

#page-ml-training .btn-disabled {
    background: var(--background);
    color: var(--text-secondary);
    border: 1px solid var(--border);
    cursor: default;
}

/* Status Badge */
#page-ml-training .status-badge {
    padding: 4px 8px;
    border-radius: 4px;
    font-size: 11px;
    font-weight: 500;
}

#page-ml-training .status-completed {
    background: rgba(46, 164, 79, 0.1);
    color: #2EA44F;
}

#page-ml-training .status-failed {
    background: rgba(209, 52, 56, 0.1);
    color: #D13438;
}

#page-ml-training .status-training {
    background: rgba(230, 165, 2, 0.1);
    color: #E6A502;
}

/* Empty State */
#page-ml-training .empty-state {
    text-align: center;
    padding: 40px;
    color: var(--text-secondary);
}

#page-ml-training .empty-state-icon {
    font-size: 48px;
    margin-bottom: 16px;
}

#page-ml-training .empty-state-title {
    font-size: 14px;
    margin-bottom: 8px;
}

#page-ml-training .empty-state-desc {
    font-size: 12px;
}
</style>

<script>
(function() {
    'use strict';

    const CACHE_ENDPOINT = 'ml_training';

    let currentTrainingJobId = null;
    let trainingPollInterval = null;
    let simulationTemplates = [];

    /**
     * Initialize the training page
     */
    window.initTrainingPage = async function() {
        console.log('Initializing ML Training page...');

        // Set default dates (last 30 days)
        const endDate = new Date();
        const startDate = new Date();
        startDate.setDate(startDate.getDate() - 30);

        const endDateEl = document.getElementById('training-end-date');
        const startDateEl = document.getElementById('training-start-date');

        if (endDateEl) endDateEl.value = endDate.toISOString().split('T')[0];
        if (startDateEl) startDateEl.value = startDate.toISOString().split('T')[0];

        // Set loading state
        if (typeof CacheManager !== 'undefined') {
            CacheManager.setLoading(CACHE_ENDPOINT);
        }

        const startTime = performance.now();

        try {
            // Load all data in parallel
            const [dataStatsResult, templatesResult, modelsResult, historyResult] = await Promise.all([
                loadDataStats(),
                loadSimulationTemplates(),
                loadModels(),
                loadTrainingHistory()
            ]);

            const loadTime = Math.round(performance.now() - startTime);
            const fromCache = dataStatsResult?.fromCache || modelsResult?.fromCache || historyResult?.fromCache;

            // Update cache indicator
            if (typeof CacheManager !== 'undefined') {
                CacheManager.updateStatus(CACHE_ENDPOINT, fromCache, loadTime);
                CacheManager.clearLoading(CACHE_ENDPOINT);
            }

            console.log(`ML Training page loaded in ${loadTime}ms (from_cache: ${fromCache})`);

        } catch (error) {
            console.error('Error initializing ML Training page:', error);

            if (typeof CacheManager !== 'undefined') {
                CacheManager.setError(CACHE_ENDPOINT, 'Failed to load training data');
            }
        }
    };

    /**
     * Refresh the page data
     */
    window.refreshTrainingPage = async function() {
        if (typeof CacheManager !== 'undefined') {
            CacheManager.setLoading(CACHE_ENDPOINT);
        }

        const startTime = performance.now();

        try {
            const [dataStatsResult, modelsResult, historyResult] = await Promise.all([
                loadDataStats(),
                loadModels(),
                loadTrainingHistory()
            ]);

            const loadTime = Math.round(performance.now() - startTime);
            const fromCache = dataStatsResult?.fromCache || modelsResult?.fromCache || historyResult?.fromCache;

            if (typeof CacheManager !== 'undefined') {
                CacheManager.updateStatus(CACHE_ENDPOINT, fromCache, loadTime);
                CacheManager.clearLoading(CACHE_ENDPOINT);
            }

        } catch (error) {
            console.error('Error refreshing:', error);
            if (typeof CacheManager !== 'undefined') {
                CacheManager.setError(CACHE_ENDPOINT, 'Refresh failed');
            }
        }
    };

    /**
     * Load data statistics
     */
    async function loadDataStats() {
        try {
            const [eventsRes, modelsRes] = await Promise.all([
                fetch('/api/ml/training/data-stats'),
                fetch('/api/ml/models')
            ]);

            const eventsData = await eventsRes.json();
            const modelsData = await modelsRes.json();

            if (eventsData.success) {
                const stats = eventsData.stats;
                updateElement('stats-total-events', (stats.total_events || 0).toLocaleString());
                updateElement('stats-failed-events', (stats.failed_events || 0).toLocaleString());
                updateElement('stats-success-events', (stats.success_events || 0).toLocaleString());
                updateElement('stats-unique-ips', (stats.unique_ips || 0).toLocaleString());

                // Show/hide warning based on data count
                const minDataWarning = document.getElementById('min-data-warning');
                if (minDataWarning) {
                    minDataWarning.style.display = stats.total_events < 100 ? 'block' : 'none';
                }
            }

            if (modelsData.success) {
                updateElement('stats-trained-models', modelsData.count || 0);
                const activeModel = modelsData.models?.find(m => m.is_active);
                updateElement('stats-active-model', activeModel ? formatAlgorithmName(activeModel.algorithm) : 'None');
            }

            return { success: true, fromCache: eventsData.from_cache || modelsData.from_cache };

        } catch (error) {
            console.error('Error loading data stats:', error);
            return { success: false, fromCache: false };
        }
    }

    /**
     * Load simulation templates
     */
    async function loadSimulationTemplates() {
        try {
            const response = await fetch('/api/simulation/templates');
            const data = await response.json();

            const select = document.getElementById('sim-template');
            if (!select) return { success: false, fromCache: false };

            if (data.success && data.templates && data.templates.length > 0) {
                simulationTemplates = data.templates;
                select.innerHTML = data.templates.map(t =>
                    `<option value="${t.id}">${t.name} (${t.severity})</option>`
                ).join('');

                // Show first template info
                updateTemplateInfo(data.templates[0].id);
            } else {
                select.innerHTML = '<option value="">No templates available</option>';
            }

            return { success: true, fromCache: false };

        } catch (error) {
            console.error('Error loading templates:', error);
            const select = document.getElementById('sim-template');
            if (select) {
                select.innerHTML = '<option value="">Error loading templates</option>';
            }
            return { success: false, fromCache: false };
        }
    }

    /**
     * Update template info display
     */
    function updateTemplateInfo(templateId) {
        const template = simulationTemplates.find(t => t.id === templateId);
        const infoEl = document.getElementById('sim-template-info');
        const descEl = document.getElementById('sim-template-desc');

        if (template && infoEl && descEl) {
            infoEl.style.display = 'block';
            descEl.textContent = template.description;
        }
    }

    // Template change handler
    document.addEventListener('change', function(e) {
        if (e.target.id === 'sim-template') {
            updateTemplateInfo(e.target.value);
        }
    });

    /**
     * Run simulation
     */
    window.runSimulation = async function() {
        const templateId = document.getElementById('sim-template')?.value;
        const eventCount = parseInt(document.getElementById('sim-event-count')?.value) || 50;
        const delay = parseInt(document.getElementById('sim-delay')?.value) || 50;

        if (!templateId) {
            showNotification('Please select a template', 'error');
            return;
        }

        const btn = document.getElementById('run-sim-btn');
        if (btn) {
            btn.disabled = true;
            btn.textContent = 'Generating...';
        }

        const progress = document.getElementById('sim-progress');
        if (progress) {
            progress.style.display = 'block';
            updateElement('sim-status', 'Starting simulation...');
            setProgressBar('sim-progress-bar', 10, 'warning');
        }

        try {
            const response = await fetch('/api/simulation/execute', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    template_name: templateId,
                    parameters: {
                        event_count: eventCount,
                        delay_between_events: delay
                    }
                })
            });

            const data = await response.json();

            if (data.success) {
                updateElement('sim-status', 'Completed!');
                updateElement('sim-progress-text', `${data.summary?.events_generated || 0} events`);
                setProgressBar('sim-progress-bar', 100, 'success');

                // Refresh stats after delay
                setTimeout(() => {
                    loadDataStats();
                    if (progress) progress.style.display = 'none';
                    setProgressBar('sim-progress-bar', 0, 'warning');
                }, 2000);
            } else {
                throw new Error(data.error || 'Simulation failed');
            }
        } catch (error) {
            updateElement('sim-status', 'Error: ' + error.message);
            setProgressBar('sim-progress-bar', 100, 'error');
        } finally {
            if (btn) {
                btn.disabled = false;
                btn.textContent = 'Generate Events';
            }
        }
    };

    /**
     * Quick generate events
     */
    window.quickGenerate = async function(templateId, buttonEl) {
        const btns = document.querySelectorAll('.quick-gen-btn');
        btns.forEach(b => {
            b.disabled = true;
            b.classList.remove('loading');
        });

        if (buttonEl) {
            buttonEl.classList.add('loading');
        }

        try {
            const response = await fetch('/api/simulation/execute', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    template_name: templateId,
                    parameters: { event_count: 50, delay_between_events: 20 }
                })
            });

            const data = await response.json();

            if (data.success) {
                loadDataStats();
                if (typeof showNotification === 'function') {
                    showNotification(`Generated ${data.summary?.events_generated || 50} events`, 'success');
                }
            } else {
                if (typeof showNotification === 'function') {
                    showNotification('Error: ' + (data.error || 'Generation failed'), 'error');
                }
            }
        } catch (error) {
            if (typeof showNotification === 'function') {
                showNotification('Error: ' + error.message, 'error');
            }
        } finally {
            btns.forEach(b => {
                b.disabled = false;
                b.classList.remove('loading');
            });
        }
    };

    /**
     * Load trained models
     */
    async function loadModels() {
        try {
            const response = await fetch('/api/ml/models');
            const data = await response.json();

            const container = document.getElementById('models-container');
            if (!container) return { success: false, fromCache: false };

            if (data.success && data.models && data.models.length > 0) {
                container.innerHTML = `
                    <div class="models-grid">
                        ${data.models.map(model => renderModelCard(model)).join('')}
                    </div>
                `;
            } else {
                container.innerHTML = `
                    <div class="empty-state">
                        <div class="empty-state-icon">ðŸ¤–</div>
                        <div class="empty-state-title">No models trained yet</div>
                        <div class="empty-state-desc">Generate training data and train your first model above</div>
                    </div>
                `;
            }

            return { success: true, fromCache: data.from_cache === true };

        } catch (error) {
            console.error('Error loading models:', error);
            return { success: false, fromCache: false };
        }
    }

    /**
     * Render a model card
     */
    function renderModelCard(model) {
        const badgeClass = model.is_active ? 'active' : model.status === 'candidate' ? 'candidate' : 'deprecated';
        const badgeText = model.is_active ? 'ACTIVE' : model.status.toUpperCase();

        return `
            <div class="model-card ${model.is_active ? 'active' : ''}">
                <div class="model-header">
                    <div>
                        <div class="model-name">${formatAlgorithmName(model.algorithm)}</div>
                        <div class="model-version">v${model.version}</div>
                    </div>
                    <span class="model-badge ${badgeClass}">${badgeText}</span>
                </div>
                <div class="model-metrics">
                    <div>
                        <div class="metric-label">Accuracy</div>
                        <div class="metric-value good">${model.metrics?.accuracy ? (model.metrics.accuracy * 100).toFixed(1) + '%' : '-'}</div>
                    </div>
                    <div>
                        <div class="metric-label">F1 Score</div>
                        <div class="metric-value good">${model.metrics?.f1_score ? (model.metrics.f1_score * 100).toFixed(1) + '%' : '-'}</div>
                    </div>
                    <div>
                        <div class="metric-label">Precision</div>
                        <div class="metric-value">${model.metrics?.precision ? (model.metrics.precision * 100).toFixed(1) + '%' : '-'}</div>
                    </div>
                    <div>
                        <div class="metric-label">Recall</div>
                        <div class="metric-value">${model.metrics?.recall ? (model.metrics.recall * 100).toFixed(1) + '%' : '-'}</div>
                    </div>
                </div>
                <div class="model-samples">
                    Samples: ${model.training_samples?.toLocaleString() || 0} train / ${model.test_samples?.toLocaleString() || 0} test
                </div>
                <div class="model-actions">
                    ${!model.is_active ? `
                        <button onclick="promoteModel(${model.id})" class="btn btn-success">Promote to Production</button>
                    ` : `
                        <button class="btn btn-disabled" disabled>Currently Active</button>
                    `}
                    <button onclick="deprecateModel(${model.id})" class="btn btn-outline-danger" style="flex: 0 0 auto; padding: 8px 12px;">Delete</button>
                </div>
            </div>
        `;
    }

    /**
     * Promote a model to production
     */
    window.promoteModel = async function(modelId) {
        if (!confirm('Promote this model to production? It will become the active model for threat detection.')) {
            return;
        }

        try {
            const response = await fetch(`/api/ml/models/${modelId}/promote`, { method: 'POST' });
            const data = await response.json();

            if (data.success) {
                loadModels();
                loadDataStats();
                if (typeof showNotification === 'function') {
                    showNotification('Model promoted to production', 'success');
                }
            } else {
                if (typeof showNotification === 'function') {
                    showNotification('Error: ' + (data.error || 'Failed to promote model'), 'error');
                }
            }
        } catch (error) {
            if (typeof showNotification === 'function') {
                showNotification('Error: ' + error.message, 'error');
            }
        }
    };

    /**
     * Deprecate (delete) a model
     */
    window.deprecateModel = async function(modelId) {
        if (!confirm('Delete this model? This action cannot be undone.')) {
            return;
        }

        try {
            const response = await fetch(`/api/ml/models/${modelId}/deprecate`, { method: 'POST' });
            const data = await response.json();

            if (data.success) {
                loadModels();
                loadDataStats();
                if (typeof showNotification === 'function') {
                    showNotification('Model deleted', 'success');
                }
            } else {
                if (typeof showNotification === 'function') {
                    showNotification('Error: ' + (data.error || 'Failed to delete model'), 'error');
                }
            }
        } catch (error) {
            if (typeof showNotification === 'function') {
                showNotification('Error: ' + error.message, 'error');
            }
        }
    };

    /**
     * Start model training
     */
    window.startTraining = async function() {
        const algorithm = document.getElementById('training-algorithm')?.value;
        const startDate = document.getElementById('training-start-date')?.value;
        const endDate = document.getElementById('training-end-date')?.value;
        const includeSim = document.getElementById('training-include-sim')?.checked;

        if (!startDate || !endDate) {
            showNotification('Please select start and end dates', 'error');
            return;
        }

        const btn = document.getElementById('start-training-btn');
        if (btn) {
            btn.disabled = true;
            btn.textContent = 'Starting...';
        }

        const progress = document.getElementById('training-progress');
        if (progress) {
            progress.style.display = 'block';
            updateElement('training-stage', 'Starting...');
            updateElement('training-progress-percent', '0%');
            setProgressBar('training-progress-bar', 0, 'success');
            updateElement('training-message', 'Preparing training job...');
        }

        try {
            const response = await fetch('/api/ml/training/start', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    algorithm: algorithm,
                    data_start: startDate,
                    data_end: endDate,
                    include_simulation: includeSim
                })
            });

            const data = await response.json();

            if (data.success) {
                currentTrainingJobId = data.job_id;
                pollTrainingStatus();
            } else {
                showNotification('Failed to start training: ' + (data.error || 'Unknown error'), 'error');
                resetTrainingUI();
            }

        } catch (error) {
            showNotification('Error starting training: ' + error.message, 'error');
            resetTrainingUI();
        }
    };

    /**
     * Poll for training status
     */
    function pollTrainingStatus() {
        if (trainingPollInterval) clearInterval(trainingPollInterval);

        trainingPollInterval = setInterval(async () => {
            if (!currentTrainingJobId) {
                clearInterval(trainingPollInterval);
                return;
            }

            try {
                const response = await fetch(`/api/ml/training/status/${currentTrainingJobId}`);
                const data = await response.json();

                if (data.success && data.job) {
                    const job = data.job;

                    updateElement('training-stage', job.stage || 'Processing...');
                    updateElement('training-progress-percent', (job.progress || 0) + '%');
                    setProgressBar('training-progress-bar', job.progress || 0, 'success');
                    updateElement('training-message', job.message || '');

                    if (job.stage === 'completed' || job.stage === 'failed') {
                        clearInterval(trainingPollInterval);
                        currentTrainingJobId = null;

                        if (job.stage === 'completed') {
                            setProgressBar('training-progress-bar', 100, 'success');
                            loadModels();
                            loadDataStats();
                            loadTrainingHistory();
                            if (typeof showNotification === 'function') {
                                showNotification('Model training completed successfully!', 'success');
                            }
                        } else {
                            setProgressBar('training-progress-bar', 100, 'error');
                            updateElement('training-message', 'Error: ' + (job.error || 'Training failed'));
                        }

                        resetTrainingUI();
                    }
                }
            } catch (error) {
                console.error('Error polling training status:', error);
            }
        }, 2000);
    }

    /**
     * Reset training UI state
     */
    function resetTrainingUI() {
        const btn = document.getElementById('start-training-btn');
        if (btn) {
            btn.disabled = false;
            btn.textContent = 'Start Training';
        }
    }

    /**
     * Load training history
     */
    async function loadTrainingHistory() {
        try {
            const response = await fetch('/api/ml/training/runs?limit=20');
            const data = await response.json();

            const tbody = document.getElementById('training-history-body');
            if (!tbody) return { success: false, fromCache: false };

            if (data.success && data.runs && data.runs.length > 0) {
                tbody.innerHTML = data.runs.map(run => renderTrainingRow(run)).join('');
            } else {
                tbody.innerHTML = '<tr><td colspan="7" class="loading-placeholder">No training runs yet</td></tr>';
            }

            return { success: true, fromCache: data.from_cache === true };

        } catch (error) {
            console.error('Error loading training history:', error);
            return { success: false, fromCache: false };
        }
    }

    /**
     * Render a training history row
     */
    function renderTrainingRow(run) {
        const statusClass = run.status === 'completed' ? 'status-completed' :
                           run.status === 'failed' ? 'status-failed' :
                           run.status === 'training' ? 'status-training' : '';

        return `
            <tr>
                <td style="font-family: monospace; font-size: 12px;">${run.uuid?.substring(0, 8) || '-'}</td>
                <td>${formatAlgorithmName(run.algorithm)}</td>
                <td class="text-center">
                    ${run.samples?.training?.toLocaleString() || '-'} / ${run.samples?.test?.toLocaleString() || '-'}
                </td>
                <td class="text-center">
                    <span class="status-badge ${statusClass}">${run.status.toUpperCase()}</span>
                </td>
                <td class="text-center" style="color: var(--text-secondary);">${run.duration_seconds ? formatDuration(run.duration_seconds) : '-'}</td>
                <td class="text-center" style="font-weight: 600; color: #2EA44F;">${run.result_model?.f1_score ? (run.result_model.f1_score * 100).toFixed(1) + '%' : '-'}</td>
                <td style="color: var(--text-secondary); font-size: 12px;">${run.started_at ? new Date(run.started_at).toLocaleString() : '-'}</td>
            </tr>
        `;
    }

    /**
     * Helper: Update element text content
     */
    function updateElement(id, value) {
        const el = document.getElementById(id);
        if (el) el.textContent = value;
    }

    /**
     * Helper: Set progress bar width and color
     */
    function setProgressBar(id, percent, type) {
        const bar = document.getElementById(id);
        if (bar) {
            bar.style.width = percent + '%';
            bar.className = 'progress-bar progress-bar-' + type;
        }
    }

    /**
     * Helper: Format algorithm name
     */
    function formatAlgorithmName(name) {
        if (!name) return '-';
        return name.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
    }

    /**
     * Helper: Format duration
     */
    function formatDuration(seconds) {
        if (seconds < 60) return seconds + 's';
        if (seconds < 3600) return Math.floor(seconds / 60) + 'm ' + (seconds % 60) + 's';
        return Math.floor(seconds / 3600) + 'h ' + Math.floor((seconds % 3600) / 60) + 'm';
    }

    /**
     * Helper: Show notification (fallback)
     */
    function showNotification(message, type) {
        if (typeof window.showNotification === 'function') {
            window.showNotification(message, type);
        } else {
            console.log(`[${type}] ${message}`);
            if (type === 'error') {
                alert(message);
            }
        }
    }

})();
</script>
